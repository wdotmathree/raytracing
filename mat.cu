#include "mat.hpp"

// Get an identity matrix

special void mat2_identity(mat2 m) {
	memset(m, 0, sizeof(float) * 4);
	m[0][0] = 1;
	m[1][1] = 1;
}

special void mat3_identity(mat3 m) {
	memset(m, 0, sizeof(float) * 9);
	m[0][0] = 1;
	m[1][1] = 1;
	m[2][2] = 1;
}

special void mat4_identity(mat4 m) {
	memset(m, 0, sizeof(float) * 16);
	m[0][0] = 1;
	m[1][1] = 1;
	m[2][2] = 1;
	m[3][3] = 1;
}

// Transpose a matrix

special void mat2_transpose(mat2 m) {
	float tmp = m[0][1];
	m[0][1] = m[1][0];
	m[1][0] = tmp;
}

special void mat3_transpose(mat3 m) {
	float tmp = m[0][1];
	m[0][1] = m[1][0];
	m[1][0] = tmp;
	tmp = m[0][2];
	m[0][2] = m[2][0];
	m[2][0] = tmp;
	tmp = m[1][2];
	m[1][2] = m[2][1];
	m[2][1] = tmp;
}

special void mat4_transpose(mat4 m) {
	float tmp = m[0][1];
	m[0][1] = m[1][0];
	m[1][0] = tmp;
	tmp = m[0][2];
	m[0][2] = m[2][0];
	m[2][0] = tmp;
	tmp = m[0][3];
	m[0][3] = m[3][0];
	m[3][0] = tmp;
	tmp = m[1][2];
	m[1][2] = m[2][1];
	m[2][1] = tmp;
	tmp = m[1][3];
	m[1][3] = m[3][1];
	m[3][1] = tmp;
	tmp = m[2][3];
	m[2][3] = m[3][2];
	m[3][2] = tmp;
}

// Get the determinant of a matrix

special float mat2_det(const mat2 m) {
	return m[0][0] * m[1][1] - m[0][1] * m[1][0];
}

special float mat3_det(const mat3 m) {
	return m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1]) - m[0][1] * (m[1][0] * m[2][2] - m[1][2] * m[2][0]) +
		   m[0][2] * (m[1][0] * m[2][1] - m[1][1] * m[2][0]);
}

special float mat4_det(const mat4 m) {
	return m[0][0] * (m[1][1] * (m[2][2] * m[3][3] - m[2][3] * m[3][2]) - m[1][2] * (m[2][1] * m[3][3] - m[2][3] * m[3][1]) +
					  m[1][3] * (m[2][1] * m[3][2] - m[2][2] * m[3][1])) -
		   m[0][1] * (m[1][0] * (m[2][2] * m[3][3] - m[2][3] * m[3][2]) - m[1][2] * (m[2][0] * m[3][3] - m[2][3] * m[3][0]) +
					  m[1][3] * (m[2][0] * m[3][2] - m[2][2] * m[3][0])) +
		   m[0][2] * (m[1][0] * (m[2][1] * m[3][3] - m[2][3] * m[3][1]) - m[1][1] * (m[2][0] * m[3][3] - m[2][3] * m[3][0]) +
					  m[1][3] * (m[2][0] * m[3][1] - m[2][1] * m[3][0])) -
		   m[0][3] * (m[1][0] * (m[2][1] * m[3][2] - m[2][2] * m[3][1]) - m[1][1] * (m[2][0] * m[3][2] - m[2][2] * m[3][0]) +
					  m[1][2] * (m[2][0] * m[3][1] - m[2][1] * m[3][0]));
}

// Invert a matrix

special float mat2_invert(mat2 inv, const mat2 m) {
	float det = mat2_det(m);
	if (__builtin_expect(det == 0, false))
		return 0;
	inv[0][0] = m[1][1] / det;
	inv[1][1] = m[0][0] / det;
	inv[0][1] = -m[0][1] / det;
	inv[1][0] = -m[1][0] / det;
	return det;
}

special float mat3_invert(mat3 inv, const mat3 m) {
	float det = mat3_det(m);
	if (__builtin_expect(det == 0, false))
		return 0;
	inv[0][0] = (m[1][1] * m[2][2] - m[1][2] * m[2][1]) / det;
	inv[0][1] = (m[0][2] * m[2][1] - m[0][1] * m[2][2]) / det;
	inv[0][2] = (m[0][1] * m[1][2] - m[0][2] * m[1][1]) / det;
	inv[1][0] = (m[1][2] * m[2][0] - m[1][0] * m[2][2]) / det;
	inv[1][1] = (m[0][0] * m[2][2] - m[0][2] * m[2][0]) / det;
	inv[1][2] = (m[0][2] * m[1][0] - m[0][0] * m[1][2]) / det;
	inv[2][0] = (m[1][0] * m[2][1] - m[1][1] * m[2][0]) / det;
	inv[2][1] = (m[0][1] * m[2][0] - m[0][0] * m[2][1]) / det;
	inv[2][2] = (m[0][0] * m[1][1] - m[0][1] * m[1][0]) / det;
	return det;
}

special float mat4_invert(mat4 inv, const mat4 m) {
	float det = mat4_det(m);
	if (__builtin_expect(det == 0, false))
		return 0;
	inv[0][0] = (m[1][1] * (m[2][2] * m[3][3] - m[2][3] * m[3][2]) - m[1][2] * (m[2][1] * m[3][3] - m[2][3] * m[3][1]) +
				 m[1][3] * (m[2][1] * m[3][2] - m[2][2] * m[3][1])) /
				det;
	inv[0][1] = (m[0][2] * (m[2][1] * m[3][3] - m[2][3] * m[3][1]) - m[0][1] * (m[2][2] * m[3][3] - m[2][3] * m[3][2]) +
				 m[0][3] * (m[2][2] * m[3][1] - m[2][1] * m[3][2])) /
				det;
	inv[0][2] = (m[0][1] * (m[1][2] * m[3][3] - m[1][3] * m[3][2]) - m[0][2] * (m[1][1] * m[3][3] - m[1][3] * m[3][1]) +
				 m[0][3] * (m[1][1] * m[3][2] - m[1][2] * m[3][1])) /
				det;
	inv[0][3] = (m[0][1] * (m[1][3] * m[2][2] - m[1][2] * m[2][3]) - m[0][2] * (m[1][3] * m[2][1] - m[1][1] * m[2][3]) +
				 m[0][3] * (m[1][2] * m[2][1] - m[1][1] * m[2][2])) /
				det;
	inv[1][0] = (m[1][2] * (m[2][0] * m[3][3] - m[2][3] * m[3][0]) - m[1][0] * (m[2][2] * m[3][3] - m[2][3] * m[3][2]) +
				 m[1][3] * (m[2][2] * m[3][0] - m[2][0] * m[3][2])) /
				det;
	inv[1][1] = (m[0][0] * (m[2][2] * m[3][3] - m[2][3] * m[3][2]) - m[0][2] * (m[2][0] * m[3][3] - m[2][3] * m[3][0]) +
				 m[0][3] * (m[2][0] * m[3][2] - m[2][2] * m[3][0])) /
				det;
	inv[1][2] = (m[0][2] * (m[1][0] * m[3][3] - m[1][3] * m[3][0]) - m[0][0] * (m[1][2] * m[3][3] - m[1][3] * m[3][2]) +
				 m[0][3] * (m[1][2] * m[3][0] - m[1][0] * m[3][2])) /
				det;
	inv[1][3] = (m[0][0] * (m[1][2] * m[2][3] - m[1][3] * m[2][2]) - m[0][2] * (m[1][0] * m[2][3] - m[1][3] * m[2][0]) +
				 m[0][3] * (m[1][0] * m[2][2] - m[1][2] * m[2][0])) /
				det;
	inv[2][0] = (m[1][0] * (m[2][1] * m[3][3] - m[2][3] * m[3][1]) - m[1][1] * (m[2][0] * m[3][3] - m[2][3] * m[3][0]) +
				 m[1][3] * (m[2][0] * m[3][1] - m[2][1] * m[3][0])) /
				det;
	inv[2][1] = (m[0][1] * (m[2][0] * m[3][3] - m[2][3] * m[3][0]) - m[0][0] * (m[2][1] * m[3][3] - m[2][3] * m[3][1]) +
				 m[0][3] * (m[2][1] * m[3][0] - m[2][0] * m[3][1])) /
				det;
	inv[2][2] = (m[0][0] * (m[1][1] * m[3][3] - m[1][3] * m[3][1]) - m[0][1] * (m[1][0] * m[3][3] - m[1][3] * m[3][0]) +
				 m[0][3] * (m[1][0] * m[3][1] - m[1][1] * m[3][0])) /
				det;
	inv[2][3] = (m[0][0] * (m[1][3] * m[2][1] - m[1][1] * m[2][3]) - m[0][1] * (m[1][3] * m[2][0] - m[1][0] * m[2][3]) +
				 m[0][3] * (m[1][1] * m[2][0] - m[1][0] * m[2][1])) /
				det;
	inv[3][0] = (m[1][1] * (m[2][0] * m[3][2] - m[2][2] * m[3][0]) - m[1][2] * (m[2][0] * m[3][1] - m[2][1] * m[3][0]) +
				 m[1][0] * (m[2][2] * m[3][1] - m[2][1] * m[3][2])) /
				det;
	inv[3][1] = (m[0][0] * (m[2][1] * m[3][2] - m[2][2] * m[3][1]) - m[0][1] * (m[2][0] * m[3][2] - m[2][2] * m[3][0]) +
				 m[0][2] * (m[2][0] * m[3][1] - m[2][1] * m[3][0])) /
				det;
	inv[3][2] = (m[0][1] * (m[1][0] * m[3][2] - m[1][2] * m[3][0]) - m[0][0] * (m[1][1] * m[3][2] - m[1][2] * m[3][1]) +
				 m[0][2] * (m[1][1] * m[3][0] - m[1][0] * m[3][1])) /
				det;
	inv[3][3] = (m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1]) - m[0][1] * (m[1][0] * m[2][2] - m[1][2] * m[2][0]) +
				 m[0][2] * (m[1][0] * m[2][1] - m[1][1] * m[2][0])) /
				det;
	return det;
}

// Multiply two matrices

special void mat2_mul(mat2 out, const mat2 a, const mat2 b) {
	out[0][0] = a[0][0] * b[0][0] + a[0][1] * b[1][0];
	out[0][1] = a[0][0] * b[0][1] + a[0][1] * b[1][1];
	out[1][0] = a[1][0] * b[0][0] + a[1][1] * b[1][0];
	out[1][1] = a[1][0] * b[0][1] + a[1][1] * b[1][1];
}

special void mat3_mul(mat3 out, const mat3 a, const mat3 b) {
	out[0][0] = a[0][0] * b[0][0] + a[0][1] * b[1][0] + a[0][2] * b[2][0];
	out[0][1] = a[0][0] * b[0][1] + a[0][1] * b[1][1] + a[0][2] * b[2][1];
	out[0][2] = a[0][0] * b[0][2] + a[0][1] * b[1][2] + a[0][2] * b[2][2];
	out[1][0] = a[1][0] * b[0][0] + a[1][1] * b[1][0] + a[1][2] * b[2][0];
	out[1][1] = a[1][0] * b[0][1] + a[1][1] * b[1][1] + a[1][2] * b[2][1];
	out[1][2] = a[1][0] * b[0][2] + a[1][1] * b[1][2] + a[1][2] * b[2][2];
	out[2][0] = a[2][0] * b[0][0] + a[2][1] * b[1][0] + a[2][2] * b[2][0];
	out[2][1] = a[2][0] * b[0][1] + a[2][1] * b[1][1] + a[2][2] * b[2][1];
	out[2][2] = a[2][0] * b[0][2] + a[2][1] * b[1][2] + a[2][2] * b[2][2];
}

special void mat4_mul(mat4 out, const mat4 a, const mat4 b) {
	out[0][0] = a[0][0] * b[0][0] + a[0][1] * b[1][0] + a[0][2] * b[2][0] + a[0][3] * b[3][0];
	out[0][1] = a[0][0] * b[0][1] + a[0][1] * b[1][1] + a[0][2] * b[2][1] + a[0][3] * b[3][1];
	out[0][2] = a[0][0] * b[0][2] + a[0][1] * b[1][2] + a[0][2] * b[2][2] + a[0][3] * b[3][2];
	out[0][3] = a[0][0] * b[0][3] + a[0][1] * b[1][3] + a[0][2] * b[2][3] + a[0][3] * b[3][3];
	out[1][0] = a[1][0] * b[0][0] + a[1][1] * b[1][0] + a[1][2] * b[2][0] + a[1][3] * b[3][0];
	out[1][1] = a[1][0] * b[0][1] + a[1][1] * b[1][1] + a[1][2] * b[2][1] + a[1][3] * b[3][1];
	out[1][2] = a[1][0] * b[0][2] + a[1][1] * b[1][2] + a[1][2] * b[2][2] + a[1][3] * b[3][2];
	out[1][3] = a[1][0] * b[0][3] + a[1][1] * b[1][3] + a[1][2] * b[2][3] + a[1][3] * b[3][3];
	out[2][0] = a[2][0] * b[0][0] + a[2][1] * b[1][0] + a[2][2] * b[2][0] + a[2][3] * b[3][0];
	out[2][1] = a[2][0] * b[0][1] + a[2][1] * b[1][1] + a[2][2] * b[2][1] + a[2][3] * b[3][1];
	out[2][2] = a[2][0] * b[0][2] + a[2][1] * b[1][2] + a[2][2] * b[2][2] + a[2][3] * b[3][2];
	out[2][3] = a[2][0] * b[0][3] + a[2][1] * b[1][3] + a[2][2] * b[2][3] + a[2][3] * b[3][3];
	out[3][0] = a[3][0] * b[0][0] + a[3][1] * b[1][0] + a[3][2] * b[2][0] + a[3][3] * b[3][0];
	out[3][1] = a[3][0] * b[0][1] + a[3][1] * b[1][1] + a[3][2] * b[2][1] + a[3][3] * b[3][1];
	out[3][2] = a[3][0] * b[0][2] + a[3][1] * b[1][2] + a[3][2] * b[2][2] + a[3][3] * b[3][2];
	out[3][3] = a[3][0] * b[0][3] + a[3][1] * b[1][3] + a[3][2] * b[2][3] + a[3][3] * b[3][3];
}

// Multiply matrix with a vector

special void mat2_mul_vec(float2 *out, const mat2 m, const float2 *v) {
	if (out == v) {
		float2 tmp;
		tmp.x = m[0][0] * v->x + m[0][1] * v->y;
		tmp.y = m[1][0] * v->x + m[1][1] * v->y;
		*out = tmp;
	} else {
		out->x = m[0][0] * v->x + m[0][1] * v->y;
		out->y = m[1][0] * v->x + m[1][1] * v->y;
	}
}

special void mat3_mul_vec(float3 *out, const mat3 m, const float3 *v) {
	if (out == v) {
		float3 tmp;
		tmp.x = m[0][0] * v->x + m[0][1] * v->y + m[0][2] * v->z;
		tmp.y = m[1][0] * v->x + m[1][1] * v->y + m[1][2] * v->z;
		tmp.z = m[2][0] * v->x + m[2][1] * v->y + m[2][2] * v->z;
		*out = tmp;
	} else {
		out->x = m[0][0] * v->x + m[0][1] * v->y + m[0][2] * v->z;
		out->y = m[1][0] * v->x + m[1][1] * v->y + m[1][2] * v->z;
		out->z = m[2][0] * v->x + m[2][1] * v->y + m[2][2] * v->z;
	}
}

special void mat4_mul_vec(float4 *out, const mat4 m, const float4 *v) {
	if (out == v) {
		float4 tmp;
		tmp.x = m[0][0] * v->x + m[0][1] * v->y + m[0][2] * v->z + m[0][3] * v->w;
		tmp.y = m[1][0] * v->x + m[1][1] * v->y + m[1][2] * v->z + m[1][3] * v->w;
		tmp.z = m[2][0] * v->x + m[2][1] * v->y + m[2][2] * v->z + m[2][3] * v->w;
		tmp.w = m[3][0] * v->x + m[3][1] * v->y + m[3][2] * v->z + m[3][3] * v->w;
		*out = tmp;
	} else {
		out->x = m[0][0] * v->x + m[0][1] * v->y + m[0][2] * v->z + m[0][3] * v->w;
		out->y = m[1][0] * v->x + m[1][1] * v->y + m[1][2] * v->z + m[1][3] * v->w;
		out->z = m[2][0] * v->x + m[2][1] * v->y + m[2][2] * v->z + m[2][3] * v->w;
		out->w = m[3][0] * v->x + m[3][1] * v->y + m[3][2] * v->z + m[3][3] * v->w;
	}
}
