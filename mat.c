#include "mat.h"

// Get an identity matrix

void mat2x2_identity(float m[2][2]) {
	memset(m, 0, sizeof(float) * 4);
	m[0][0] = 1;
	m[1][1] = 1;
}

void mat3x3_identity(float m[3][3]) {
	memset(m, 0, sizeof(float) * 9);
	m[0][0] = 1;
	m[1][1] = 1;
	m[2][2] = 1;
}

void mat4x4_identity(float m[4][4]) {
	memset(m, 0, sizeof(float) * 16);
	m[0][0] = 1;
	m[1][1] = 1;
	m[2][2] = 1;
	m[3][3] = 1;
}

// Transpose a matrix

void mat2x2_transpose(float m[2][2]) {
	float tmp = m[0][1];
	m[0][1] = m[1][0];
	m[1][0] = tmp;
}

void mat3x3_transpose(float m[3][3]) {
	float tmp = m[0][1];
	m[0][1] = m[1][0];
	m[1][0] = tmp;
	tmp = m[0][2];
	m[0][2] = m[2][0];
	m[2][0] = tmp;
	tmp = m[1][2];
	m[1][2] = m[2][1];
	m[2][1] = tmp;
}

void mat4x4_transpose(float m[4][4]) {
	float tmp = m[0][1];
	m[0][1] = m[1][0];
	m[1][0] = tmp;
	tmp = m[0][2];
	m[0][2] = m[2][0];
	m[2][0] = tmp;
	tmp = m[0][3];
	m[0][3] = m[3][0];
	m[3][0] = tmp;
	tmp = m[1][2];
	m[1][2] = m[2][1];
	m[2][1] = tmp;
	tmp = m[1][3];
	m[1][3] = m[3][1];
	m[3][1] = tmp;
	tmp = m[2][3];
	m[2][3] = m[3][2];
	m[3][2] = tmp;
}

// Get the determinant of a matrix

float mat2x2_det(const float m[2][2]) { return m[0][0] * m[1][1] - m[0][1] * m[1][0]; }

float mat3x3_det(const float m[3][3]) {
	return m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1]) - m[0][1] * (m[1][0] * m[2][2] - m[1][2] * m[2][0]) +
		   m[0][2] * (m[1][0] * m[2][1] - m[1][1] * m[2][0]);
}

float mat4x4_det(const float m[4][4]) {
	return m[0][0] * (m[1][1] * (m[2][2] * m[3][3] - m[2][3] * m[3][2]) - m[1][2] * (m[2][1] * m[3][3] - m[2][3] * m[3][1]) +
					  m[1][3] * (m[2][1] * m[3][2] - m[2][2] * m[3][1])) -
		   m[0][1] * (m[1][0] * (m[2][2] * m[3][3] - m[2][3] * m[3][2]) - m[1][2] * (m[2][0] * m[3][3] - m[2][3] * m[3][0]) +
					  m[1][3] * (m[2][0] * m[3][2] - m[2][2] * m[3][0])) +
		   m[0][2] * (m[1][0] * (m[2][1] * m[3][3] - m[2][3] * m[3][1]) - m[1][1] * (m[2][0] * m[3][3] - m[2][3] * m[3][0]) +
					  m[1][3] * (m[2][0] * m[3][1] - m[2][1] * m[3][0])) -
		   m[0][3] * (m[1][0] * (m[2][1] * m[3][2] - m[2][2] * m[3][1]) - m[1][1] * (m[2][0] * m[3][2] - m[2][2] * m[3][0]) +
					  m[1][2] * (m[2][0] * m[3][1] - m[2][1] * m[3][0]));
}

// Invert a matrix

float mat2x2_invert(float inv[2][2], const float m[2][2]) {
	float det = mat2x2_det(m);
	if (__builtin_expect(det == 0, false))
		return 0;
	inv[0][0] = m[1][1] / det;
	inv[1][1] = m[0][0] / det;
	inv[0][1] = -m[0][1] / det;
	inv[1][0] = -m[1][0] / det;
	return det;
}

float mat3x3_invert(float inv[3][3], const float m[3][3]) {
	float det = mat3x3_det(m);
	if (__builtin_expect(det == 0, false))
		return 0;
	inv[0][0] = (m[1][1] * m[2][2] - m[1][2] * m[2][1]) / det;
	inv[0][1] = (m[0][2] * m[2][1] - m[0][1] * m[2][2]) / det;
	inv[0][2] = (m[0][1] * m[1][2] - m[0][2] * m[1][1]) / det;
	inv[1][0] = (m[1][2] * m[2][0] - m[1][0] * m[2][2]) / det;
	inv[1][1] = (m[0][0] * m[2][2] - m[0][2] * m[2][0]) / det;
	inv[1][2] = (m[0][2] * m[1][0] - m[0][0] * m[1][2]) / det;
	inv[2][0] = (m[1][0] * m[2][1] - m[1][1] * m[2][0]) / det;
	inv[2][1] = (m[0][1] * m[2][0] - m[0][0] * m[2][1]) / det;
	inv[2][2] = (m[0][0] * m[1][1] - m[0][1] * m[1][0]) / det;
	return det;
}

float mat4x4_invert(float inv[4][4], const float m[4][4]) {
	float det = mat4x4_det(m);
	if (__builtin_expect(det == 0, false))
		return 0;
	inv[0][0] = (m[1][1] * (m[2][2] * m[3][3] - m[2][3] * m[3][2]) - m[1][2] * (m[2][1] * m[3][3] - m[2][3] * m[3][1]) +
				 m[1][3] * (m[2][1] * m[3][2] - m[2][2] * m[3][1])) /
				det;
	inv[0][1] = (m[0][2] * (m[2][1] * m[3][3] - m[2][3] * m[3][1]) - m[0][1] * (m[2][2] * m[3][3] - m[2][3] * m[3][2]) +
				 m[0][3] * (m[2][2] * m[3][1] - m[2][1] * m[3][2])) /
				det;
	inv[0][2] = (m[0][1] * (m[1][2] * m[3][3] - m[1][3] * m[3][2]) - m[0][2] * (m[1][1] * m[3][3] - m[1][3] * m[3][1]) +
				 m[0][3] * (m[1][1] * m[3][2] - m[1][2] * m[3][1])) /
				det;
	inv[0][3] = (m[0][1] * (m[1][3] * m[2][2] - m[1][2] * m[2][3]) - m[0][2] * (m[1][3] * m[2][1] - m[1][1] * m[2][3]) +
				 m[0][3] * (m[1][2] * m[2][1] - m[1][1] * m[2][2])) /
				det;
	inv[1][0] = (m[1][2] * (m[2][0] * m[3][3] - m[2][3] * m[3][0]) - m[1][0] * (m[2][2] * m[3][3] - m[2][3] * m[3][2]) +
				 m[1][3] * (m[2][2] * m[3][0] - m[2][0] * m[3][2])) /
				det;
	inv[1][1] = (m[0][0] * (m[2][2] * m[3][3] - m[2][3] * m[3][2]) - m[0][2] * (m[2][0] * m[3][3] - m[2][3] * m[3][0]) +
				 m[0][3] * (m[2][0] * m[3][2] - m[2][2] * m[3][0])) /
				det;
	inv[1][2] = (m[0][2] * (m[1][0] * m[3][3] - m[1][3] * m[3][0]) - m[0][0] * (m[1][2] * m[3][3] - m[1][3] * m[3][2]) +
				 m[0][3] * (m[1][2] * m[3][0] - m[1][0] * m[3][2])) /
				det;
	inv[1][3] = (m[0][0] * (m[1][2] * m[2][3] - m[1][3] * m[2][2]) - m[0][2] * (m[1][0] * m[2][3] - m[1][3] * m[2][0]) +
				 m[0][3] * (m[1][0] * m[2][2] - m[1][2] * m[2][0])) /
				det;
	inv[2][0] = (m[1][0] * (m[2][1] * m[3][3] - m[2][3] * m[3][1]) - m[1][1] * (m[2][0] * m[3][3] - m[2][3] * m[3][0]) +
				 m[1][3] * (m[2][0] * m[3][1] - m[2][1] * m[3][0])) /
				det;
	inv[2][1] = (m[0][1] * (m[2][0] * m[3][3] - m[2][3] * m[3][0]) - m[0][0] * (m[2][1] * m[3][3] - m[2][3] * m[3][1]) +
				 m[0][3] * (m[2][1] * m[3][0] - m[2][0] * m[3][1])) /
				det;
	inv[2][2] = (m[0][0] * (m[1][1] * m[3][3] - m[1][3] * m[3][1]) - m[0][1] * (m[1][0] * m[3][3] - m[1][3] * m[3][0]) +
				 m[0][3] * (m[1][0] * m[3][1] - m[1][1] * m[3][0])) /
				det;
	inv[2][3] = (m[0][0] * (m[1][3] * m[2][1] - m[1][1] * m[2][3]) - m[0][1] * (m[1][3] * m[2][0] - m[1][0] * m[2][3]) +
				 m[0][3] * (m[1][1] * m[2][0] - m[1][0] * m[2][1])) /
				det;
	inv[3][0] = (m[1][1] * (m[2][0] * m[3][2] - m[2][2] * m[3][0]) - m[1][2] * (m[2][0] * m[3][1] - m[2][1] * m[3][0]) +
				 m[1][0] * (m[2][2] * m[3][1] - m[2][1] * m[3][2])) /
				det;
	inv[3][1] = (m[0][0] * (m[2][1] * m[3][2] - m[2][2] * m[3][1]) - m[0][1] * (m[2][0] * m[3][2] - m[2][2] * m[3][0]) +
				 m[0][2] * (m[2][0] * m[3][1] - m[2][1] * m[3][0])) /
				det;
	inv[3][2] = (m[0][1] * (m[1][0] * m[3][2] - m[1][2] * m[3][0]) - m[0][0] * (m[1][1] * m[3][2] - m[1][2] * m[3][1]) +
				 m[0][2] * (m[1][1] * m[3][0] - m[1][0] * m[3][1])) /
				det;
	inv[3][3] = (m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1]) - m[0][1] * (m[1][0] * m[2][2] - m[1][2] * m[2][0]) +
				 m[0][2] * (m[1][0] * m[2][1] - m[1][1] * m[2][0])) /
				det;
	return det;
}

// Multiply two matrices

void mat2x2_mul(float out[2][2], const float a[2][2], const float b[2][2]) {
	out[0][0] = a[0][0] * b[0][0] + a[0][1] * b[1][0];
	out[0][1] = a[0][0] * b[0][1] + a[0][1] * b[1][1];
	out[1][0] = a[1][0] * b[0][0] + a[1][1] * b[1][0];
	out[1][1] = a[1][0] * b[0][1] + a[1][1] * b[1][1];
}

void mat3x3_mul(float out[3][3], const float a[3][3], const float b[3][3]) {
	out[0][0] = a[0][0] * b[0][0] + a[0][1] * b[1][0] + a[0][2] * b[2][0];
	out[0][1] = a[0][0] * b[0][1] + a[0][1] * b[1][1] + a[0][2] * b[2][1];
	out[0][2] = a[0][0] * b[0][2] + a[0][1] * b[1][2] + a[0][2] * b[2][2];
	out[1][0] = a[1][0] * b[0][0] + a[1][1] * b[1][0] + a[1][2] * b[2][0];
	out[1][1] = a[1][0] * b[0][1] + a[1][1] * b[1][1] + a[1][2] * b[2][1];
	out[1][2] = a[1][0] * b[0][2] + a[1][1] * b[1][2] + a[1][2] * b[2][2];
	out[2][0] = a[2][0] * b[0][0] + a[2][1] * b[1][0] + a[2][2] * b[2][0];
	out[2][1] = a[2][0] * b[0][1] + a[2][1] * b[1][1] + a[2][2] * b[2][1];
	out[2][2] = a[2][0] * b[0][2] + a[2][1] * b[1][2] + a[2][2] * b[2][2];
}

void mat4x4_mul(float out[4][4], const float a[4][4], const float b[4][4]) {
	out[0][0] = a[0][0] * b[0][0] + a[0][1] * b[1][0] + a[0][2] * b[2][0] + a[0][3] * b[3][0];
	out[0][1] = a[0][0] * b[0][1] + a[0][1] * b[1][1] + a[0][2] * b[2][1] + a[0][3] * b[3][1];
	out[0][2] = a[0][0] * b[0][2] + a[0][1] * b[1][2] + a[0][2] * b[2][2] + a[0][3] * b[3][2];
	out[0][3] = a[0][0] * b[0][3] + a[0][1] * b[1][3] + a[0][2] * b[2][3] + a[0][3] * b[3][3];
	out[1][0] = a[1][0] * b[0][0] + a[1][1] * b[1][0] + a[1][2] * b[2][0] + a[1][3] * b[3][0];
	out[1][1] = a[1][0] * b[0][1] + a[1][1] * b[1][1] + a[1][2] * b[2][1] + a[1][3] * b[3][1];
	out[1][2] = a[1][0] * b[0][2] + a[1][1] * b[1][2] + a[1][2] * b[2][2] + a[1][3] * b[3][2];
	out[1][3] = a[1][0] * b[0][3] + a[1][1] * b[1][3] + a[1][2] * b[2][3] + a[1][3] * b[3][3];
	out[2][0] = a[2][0] * b[0][0] + a[2][1] * b[1][0] + a[2][2] * b[2][0] + a[2][3] * b[3][0];
	out[2][1] = a[2][0] * b[0][1] + a[2][1] * b[1][1] + a[2][2] * b[2][1] + a[2][3] * b[3][1];
	out[2][2] = a[2][0] * b[0][2] + a[2][1] * b[1][2] + a[2][2] * b[2][2] + a[2][3] * b[3][2];
	out[2][3] = a[2][0] * b[0][3] + a[2][1] * b[1][3] + a[2][2] * b[2][3] + a[2][3] * b[3][3];
	out[3][0] = a[3][0] * b[0][0] + a[3][1] * b[1][0] + a[3][2] * b[2][0] + a[3][3] * b[3][0];
	out[3][1] = a[3][0] * b[0][1] + a[3][1] * b[1][1] + a[3][2] * b[2][1] + a[3][3] * b[3][1];
	out[3][2] = a[3][0] * b[0][2] + a[3][1] * b[1][2] + a[3][2] * b[2][2] + a[3][3] * b[3][2];
	out[3][3] = a[3][0] * b[0][3] + a[3][1] * b[1][3] + a[3][2] * b[2][3] + a[3][3] * b[3][3];
}

// Multiply matrix with a vector

void mat3x3_mul_vec3(vec3 *out, const float m[3][3], const vec3 *v) {
	__m128 m0 = _mm_maskload_ps(m[0], _mm_setr_epi32(-1, -1, -1, 0));
	__m128 m1 = _mm_maskload_ps(m[1], _mm_setr_epi32(-1, -1, -1, 0));
	__m128 m2 = _mm_maskload_ps(m[2], _mm_setr_epi32(-1, -1, -1, 0));
	__m128 v0 = _mm_maskload_ps((float *)v, _mm_setr_epi32(-1, -1, -1, 0));
	m0 = _mm_mul_ps(m0, v0);
	m1 = _mm_mul_ps(m1, v0);
	m2 = _mm_mul_ps(m2, v0);
	m0 = _mm_hadd_ps(m0, m1);
	m2 = _mm_hadd_ps(m2, m2);
	m0 = _mm_hadd_ps(m0, m2);
	_mm_storeu_ps((float *)out, m0);
}

void mat4x4_mul_vec4(vec4 *out, const float m[4][4], const vec4 *v) {
	__m128 m0 = _mm_loadu_ps(m[0]);
	__m128 m1 = _mm_loadu_ps(m[1]);
	__m128 m2 = _mm_loadu_ps(m[2]);
	__m128 m3 = _mm_loadu_ps(m[3]);
	__m128 v0 = _mm_loadu_ps((float *)v);
	m0 = _mm_mul_ps(m0, v0);
	m1 = _mm_mul_ps(m1, v0);
	m2 = _mm_mul_ps(m2, v0);
	m3 = _mm_mul_ps(m3, v0);
	m0 = _mm_hadd_ps(m0, m1);
	m2 = _mm_hadd_ps(m2, m3);
	m0 = _mm_hadd_ps(m0, m2);
	_mm_storeu_ps((float *)out, m0);
}
