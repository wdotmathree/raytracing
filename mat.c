#include "mat.h"

// Get an identity matrix

void mat2x2_identity(mat2 m) {
	memset(m, 0, sizeof(float) * 4);
	m[0][0] = 1;
	m[1][1] = 1;
}

void mat3x3_identity(mat3 m) {
	memset(m, 0, sizeof(float) * 9);
	m[0][0] = 1;
	m[1][1] = 1;
	m[2][2] = 1;
}

void mat4x4_identity(mat4 m) {
	memset(m, 0, sizeof(float) * 16);
	m[0][0] = 1;
	m[1][1] = 1;
	m[2][2] = 1;
	m[3][3] = 1;
}

// Transpose a matrix

void mat2x2_transpose(mat2 m) {
	float tmp = m[0][1];
	m[0][1] = m[1][0];
	m[1][0] = tmp;
}

void mat3x3_transpose(mat3 m) {
	float tmp = m[0][1];
	m[0][1] = m[1][0];
	m[1][0] = tmp;
	tmp = m[0][2];
	m[0][2] = m[2][0];
	m[2][0] = tmp;
	tmp = m[1][2];
	m[1][2] = m[2][1];
	m[2][1] = tmp;
}

void mat4x4_transpose(mat4 m) {
	float tmp = m[0][1];
	m[0][1] = m[1][0];
	m[1][0] = tmp;
	tmp = m[0][2];
	m[0][2] = m[2][0];
	m[2][0] = tmp;
	tmp = m[0][3];
	m[0][3] = m[3][0];
	m[3][0] = tmp;
	tmp = m[1][2];
	m[1][2] = m[2][1];
	m[2][1] = tmp;
	tmp = m[1][3];
	m[1][3] = m[3][1];
	m[3][1] = tmp;
	tmp = m[2][3];
	m[2][3] = m[3][2];
	m[3][2] = tmp;
}

// Get the determinant of a matrix

float mat2x2_det(const mat2 m) { return m[0][0] * m[1][1] - m[0][1] * m[1][0]; }

float mat3x3_det(const mat3 m) {
	return m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1]) - m[0][1] * (m[1][0] * m[2][2] - m[1][2] * m[2][0]) +
		   m[0][2] * (m[1][0] * m[2][1] - m[1][1] * m[2][0]);
}

float mat4x4_det(const mat4 m) {
	return m[0][0] * (m[1][1] * (m[2][2] * m[3][3] - m[2][3] * m[3][2]) - m[1][2] * (m[2][1] * m[3][3] - m[2][3] * m[3][1]) +
					  m[1][3] * (m[2][1] * m[3][2] - m[2][2] * m[3][1])) -
		   m[0][1] * (m[1][0] * (m[2][2] * m[3][3] - m[2][3] * m[3][2]) - m[1][2] * (m[2][0] * m[3][3] - m[2][3] * m[3][0]) +
					  m[1][3] * (m[2][0] * m[3][2] - m[2][2] * m[3][0])) +
		   m[0][2] * (m[1][0] * (m[2][1] * m[3][3] - m[2][3] * m[3][1]) - m[1][1] * (m[2][0] * m[3][3] - m[2][3] * m[3][0]) +
					  m[1][3] * (m[2][0] * m[3][1] - m[2][1] * m[3][0])) -
		   m[0][3] * (m[1][0] * (m[2][1] * m[3][2] - m[2][2] * m[3][1]) - m[1][1] * (m[2][0] * m[3][2] - m[2][2] * m[3][0]) +
					  m[1][2] * (m[2][0] * m[3][1] - m[2][1] * m[3][0]));
}

// Invert a matrix

float mat2x2_invert(mat2 inv, const mat2 m) {
	float det = mat2x2_det(m);
	if (__builtin_expect(det == 0, false))
		return 0;
	inv[0][0] = m[1][1] / det;
	inv[1][1] = m[0][0] / det;
	inv[0][1] = -m[0][1] / det;
	inv[1][0] = -m[1][0] / det;
	return det;
}

float mat3x3_invert(mat3 inv, const mat3 m) {
	float det = mat3x3_det(m);
	if (__builtin_expect(det == 0, false))
		return 0;
	inv[0][0] = (m[1][1] * m[2][2] - m[1][2] * m[2][1]) / det;
	inv[0][1] = (m[0][2] * m[2][1] - m[0][1] * m[2][2]) / det;
	inv[0][2] = (m[0][1] * m[1][2] - m[0][2] * m[1][1]) / det;
	inv[1][0] = (m[1][2] * m[2][0] - m[1][0] * m[2][2]) / det;
	inv[1][1] = (m[0][0] * m[2][2] - m[0][2] * m[2][0]) / det;
	inv[1][2] = (m[0][2] * m[1][0] - m[0][0] * m[1][2]) / det;
	inv[2][0] = (m[1][0] * m[2][1] - m[1][1] * m[2][0]) / det;
	inv[2][1] = (m[0][1] * m[2][0] - m[0][0] * m[2][1]) / det;
	inv[2][2] = (m[0][0] * m[1][1] - m[0][1] * m[1][0]) / det;
	return det;
}

float mat4x4_invert(mat4 inv, const mat4 m) {
	float det = mat4x4_det(m);
	if (__builtin_expect(det == 0, false))
		return 0;
	inv[0][0] = (m[1][1] * (m[2][2] * m[3][3] - m[2][3] * m[3][2]) - m[1][2] * (m[2][1] * m[3][3] - m[2][3] * m[3][1]) +
				 m[1][3] * (m[2][1] * m[3][2] - m[2][2] * m[3][1])) /
				det;
	inv[0][1] = (m[0][2] * (m[2][1] * m[3][3] - m[2][3] * m[3][1]) - m[0][1] * (m[2][2] * m[3][3] - m[2][3] * m[3][2]) +
				 m[0][3] * (m[2][2] * m[3][1] - m[2][1] * m[3][2])) /
				det;
	inv[0][2] = (m[0][1] * (m[1][2] * m[3][3] - m[1][3] * m[3][2]) - m[0][2] * (m[1][1] * m[3][3] - m[1][3] * m[3][1]) +
				 m[0][3] * (m[1][1] * m[3][2] - m[1][2] * m[3][1])) /
				det;
	inv[0][3] = (m[0][1] * (m[1][3] * m[2][2] - m[1][2] * m[2][3]) - m[0][2] * (m[1][3] * m[2][1] - m[1][1] * m[2][3]) +
				 m[0][3] * (m[1][2] * m[2][1] - m[1][1] * m[2][2])) /
				det;
	inv[1][0] = (m[1][2] * (m[2][0] * m[3][3] - m[2][3] * m[3][0]) - m[1][0] * (m[2][2] * m[3][3] - m[2][3] * m[3][2]) +
				 m[1][3] * (m[2][2] * m[3][0] - m[2][0] * m[3][2])) /
				det;
	inv[1][1] = (m[0][0] * (m[2][2] * m[3][3] - m[2][3] * m[3][2]) - m[0][2] * (m[2][0] * m[3][3] - m[2][3] * m[3][0]) +
				 m[0][3] * (m[2][0] * m[3][2] - m[2][2] * m[3][0])) /
				det;
	inv[1][2] = (m[0][2] * (m[1][0] * m[3][3] - m[1][3] * m[3][0]) - m[0][0] * (m[1][2] * m[3][3] - m[1][3] * m[3][2]) +
				 m[0][3] * (m[1][2] * m[3][0] - m[1][0] * m[3][2])) /
				det;
	inv[1][3] = (m[0][0] * (m[1][2] * m[2][3] - m[1][3] * m[2][2]) - m[0][2] * (m[1][0] * m[2][3] - m[1][3] * m[2][0]) +
				 m[0][3] * (m[1][0] * m[2][2] - m[1][2] * m[2][0])) /
				det;
	inv[2][0] = (m[1][0] * (m[2][1] * m[3][3] - m[2][3] * m[3][1]) - m[1][1] * (m[2][0] * m[3][3] - m[2][3] * m[3][0]) +
				 m[1][3] * (m[2][0] * m[3][1] - m[2][1] * m[3][0])) /
				det;
	inv[2][1] = (m[0][1] * (m[2][0] * m[3][3] - m[2][3] * m[3][0]) - m[0][0] * (m[2][1] * m[3][3] - m[2][3] * m[3][1]) +
				 m[0][3] * (m[2][1] * m[3][0] - m[2][0] * m[3][1])) /
				det;
	inv[2][2] = (m[0][0] * (m[1][1] * m[3][3] - m[1][3] * m[3][1]) - m[0][1] * (m[1][0] * m[3][3] - m[1][3] * m[3][0]) +
				 m[0][3] * (m[1][0] * m[3][1] - m[1][1] * m[3][0])) /
				det;
	inv[2][3] = (m[0][0] * (m[1][3] * m[2][1] - m[1][1] * m[2][3]) - m[0][1] * (m[1][3] * m[2][0] - m[1][0] * m[2][3]) +
				 m[0][3] * (m[1][1] * m[2][0] - m[1][0] * m[2][1])) /
				det;
	inv[3][0] = (m[1][1] * (m[2][0] * m[3][2] - m[2][2] * m[3][0]) - m[1][2] * (m[2][0] * m[3][1] - m[2][1] * m[3][0]) +
				 m[1][0] * (m[2][2] * m[3][1] - m[2][1] * m[3][2])) /
				det;
	inv[3][1] = (m[0][0] * (m[2][1] * m[3][2] - m[2][2] * m[3][1]) - m[0][1] * (m[2][0] * m[3][2] - m[2][2] * m[3][0]) +
				 m[0][2] * (m[2][0] * m[3][1] - m[2][1] * m[3][0])) /
				det;
	inv[3][2] = (m[0][1] * (m[1][0] * m[3][2] - m[1][2] * m[3][0]) - m[0][0] * (m[1][1] * m[3][2] - m[1][2] * m[3][1]) +
				 m[0][2] * (m[1][1] * m[3][0] - m[1][0] * m[3][1])) /
				det;
	inv[3][3] = (m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1]) - m[0][1] * (m[1][0] * m[2][2] - m[1][2] * m[2][0]) +
				 m[0][2] * (m[1][0] * m[2][1] - m[1][1] * m[2][0])) /
				det;
	return det;
}

// Multiply two matrices

void mat2x2_mul(mat2 out, const mat2 a, const mat2 b) {
	out[0][0] = a[0][0] * b[0][0] + a[0][1] * b[1][0];
	out[0][1] = a[0][0] * b[0][1] + a[0][1] * b[1][1];
	out[1][0] = a[1][0] * b[0][0] + a[1][1] * b[1][0];
	out[1][1] = a[1][0] * b[0][1] + a[1][1] * b[1][1];
}

void mat3x3_mul(mat3 out, const mat3 a, const mat3 b) {
	out[0][0] = a[0][0] * b[0][0] + a[0][1] * b[1][0] + a[0][2] * b[2][0];
	out[0][1] = a[0][0] * b[0][1] + a[0][1] * b[1][1] + a[0][2] * b[2][1];
	out[0][2] = a[0][0] * b[0][2] + a[0][1] * b[1][2] + a[0][2] * b[2][2];
	out[1][0] = a[1][0] * b[0][0] + a[1][1] * b[1][0] + a[1][2] * b[2][0];
	out[1][1] = a[1][0] * b[0][1] + a[1][1] * b[1][1] + a[1][2] * b[2][1];
	out[1][2] = a[1][0] * b[0][2] + a[1][1] * b[1][2] + a[1][2] * b[2][2];
	out[2][0] = a[2][0] * b[0][0] + a[2][1] * b[1][0] + a[2][2] * b[2][0];
	out[2][1] = a[2][0] * b[0][1] + a[2][1] * b[1][1] + a[2][2] * b[2][1];
	out[2][2] = a[2][0] * b[0][2] + a[2][1] * b[1][2] + a[2][2] * b[2][2];
}

void mat4x4_mul(mat4 out, const mat4 a, const mat4 b) {
	out[0][0] = a[0][0] * b[0][0] + a[0][1] * b[1][0] + a[0][2] * b[2][0] + a[0][3] * b[3][0];
	out[0][1] = a[0][0] * b[0][1] + a[0][1] * b[1][1] + a[0][2] * b[2][1] + a[0][3] * b[3][1];
	out[0][2] = a[0][0] * b[0][2] + a[0][1] * b[1][2] + a[0][2] * b[2][2] + a[0][3] * b[3][2];
	out[0][3] = a[0][0] * b[0][3] + a[0][1] * b[1][3] + a[0][2] * b[2][3] + a[0][3] * b[3][3];
	out[1][0] = a[1][0] * b[0][0] + a[1][1] * b[1][0] + a[1][2] * b[2][0] + a[1][3] * b[3][0];
	out[1][1] = a[1][0] * b[0][1] + a[1][1] * b[1][1] + a[1][2] * b[2][1] + a[1][3] * b[3][1];
	out[1][2] = a[1][0] * b[0][2] + a[1][1] * b[1][2] + a[1][2] * b[2][2] + a[1][3] * b[3][2];
	out[1][3] = a[1][0] * b[0][3] + a[1][1] * b[1][3] + a[1][2] * b[2][3] + a[1][3] * b[3][3];
	out[2][0] = a[2][0] * b[0][0] + a[2][1] * b[1][0] + a[2][2] * b[2][0] + a[2][3] * b[3][0];
	out[2][1] = a[2][0] * b[0][1] + a[2][1] * b[1][1] + a[2][2] * b[2][1] + a[2][3] * b[3][1];
	out[2][2] = a[2][0] * b[0][2] + a[2][1] * b[1][2] + a[2][2] * b[2][2] + a[2][3] * b[3][2];
	out[2][3] = a[2][0] * b[0][3] + a[2][1] * b[1][3] + a[2][2] * b[2][3] + a[2][3] * b[3][3];
	out[3][0] = a[3][0] * b[0][0] + a[3][1] * b[1][0] + a[3][2] * b[2][0] + a[3][3] * b[3][0];
	out[3][1] = a[3][0] * b[0][1] + a[3][1] * b[1][1] + a[3][2] * b[2][1] + a[3][3] * b[3][1];
	out[3][2] = a[3][0] * b[0][2] + a[3][1] * b[1][2] + a[3][2] * b[2][2] + a[3][3] * b[3][2];
	out[3][3] = a[3][0] * b[0][3] + a[3][1] * b[1][3] + a[3][2] * b[2][3] + a[3][3] * b[3][3];
}

// Multiply matrix with a vector

void mat3x3_mul_vec3(vec3 *out, const mat3 m, const vec3 *v) {
	__m128 m0 = _mm_maskload_ps(m[0], _mm_setr_epi32(-1, -1, -1, 0));
	__m128 m1 = _mm_maskload_ps(m[1], _mm_setr_epi32(-1, -1, -1, 0));
	__m128 m2 = _mm_maskload_ps(m[2], _mm_setr_epi32(-1, -1, -1, 0));
	__m128 v0 = _mm_maskload_ps((float *)v, _mm_setr_epi32(-1, -1, -1, 0));
	m0 = _mm_mul_ps(m0, v0);
	m1 = _mm_mul_ps(m1, v0);
	m2 = _mm_mul_ps(m2, v0);
	m0 = _mm_hadd_ps(m0, m1);
	m2 = _mm_hadd_ps(m2, m2);
	m0 = _mm_hadd_ps(m0, m2);
	_mm_storeu_ps((float *)out, m0);
}

void mat4x4_mul_vec4(vec4 *out, const mat4 m, const vec4 *v) {
	__m128 m0 = _mm_loadu_ps(m[0]);
	__m128 m1 = _mm_loadu_ps(m[1]);
	__m128 m2 = _mm_loadu_ps(m[2]);
	__m128 m3 = _mm_loadu_ps(m[3]);
	__m128 v0 = _mm_loadu_ps((float *)v);
	m0 = _mm_mul_ps(m0, v0);
	m1 = _mm_mul_ps(m1, v0);
	m2 = _mm_mul_ps(m2, v0);
	m3 = _mm_mul_ps(m3, v0);
	m0 = _mm_hadd_ps(m0, m1);
	m2 = _mm_hadd_ps(m2, m3);
	m0 = _mm_hadd_ps(m0, m2);
	_mm_storeu_ps((float *)out, m0);
}